---
categories: technology
layout: post
---

- Table
{:toc}

# 所有权

数据可能分配在栈上和堆上。一个分配在栈上的数据可以通过默认的浅拷贝完整克隆，也更为廉价。而需要共享的数据更适合分配在堆上，这样只需要在栈上保留一个指向堆位置的指针即可，这样可以避免大量的拷贝操作。如果想要同时拷贝堆上的数据，可以用`clone`方法。

栈上的数据在退栈的时候会被自动释放，但是堆上不同。堆上的数据由于可能被多个指针引用，不能轻易决定释放时机。

Rust中引入所有权的概念，一个数据的所有权被正好一个变量获得，当这个变量离开作用域的时候，它的数据也会被销毁。

```rust
    let s1 = String::from("hello");
    let s2 = s1; //s2接管s1的所有权，s1失去了所有权，不能再被使用
```

在栈上直接分配的数据实现了名为`Copy`的`traits`，在赋值给另外一个变量的时候并不会失去所有权，而是将数据完整拷贝给了另外一个变量。

```rust
    let x = 5;
    let y = x; //x并不会失去所有权
```

以下类型的数据实现了`Copy`的`traits`：

- 基础类型
- 仅包含实现了`Copy`的`traits`数据的元组

# 引用

```rust
fn take_ownership(x: String){ //
    println!("{}", x);
}

fn main(){
    let s = String::from("hello");
    take_ownership(s); //这里s失去所有权
}
```

由于将数据作为函数参数传递也会使得变量失去所有权，因此我们必须将所有权从函数中传回。

```rust
fn take_ownership(x: String) -> String{ //
    println!("{}", x);
    x
}

fn main(){
    let s = String::from("hello");
    let s = take_ownership(s);
}
```

这样做很麻烦，尤其在参数比较多的情况下。我们可以用引用来优化这一过程。


```rust
fn borrow(x: & String){ 
    println!("{}", x);
}

fn main(){
    let s = String::from("hello");
    borrow(& s);// 这里s不会失去所有权
}
```

引用也分为`mut`和`immutable`两种。前者会对数据加写锁，后者会对数据加读锁（这里并不真的在运行期加锁，实际上都是编译期的工作，这里只是为了方便理解）。因此一个数据最多有一个`mut`类型的应用，或者多个`immutable`类型的引用。之所有这么设计是为了防止race condition。

```rust
fn main(){
    let mut s = String::from("hello"); //s得到所有权
    let mut_ref_s = &mut s; //获得一个mut引用
    mut_ref_s.push_str(" world"); //修改mut引用，由于这里是mut_ref_s的最后一次被使用，因此它的生命周期在此结束
    let immutable_ref_s = &s; //创建一个immutable引用
    println!("{}", immutable_ref_s);
}
```

如果所有权变量被销毁，那么所有存活的引用（这种引用称为悬置引用，dangling reference）都是不可用的，这时候再使用这些引用对象会引起编译错误。

```rust
fn wrong() -> &String {
    let s = String::from("hello");
    &s //在这语句后s会销毁，因此返回的引用也将非法
}

fn correct() -> String {
    let s = String::from("hello");
    s //返回所有权可以避免数据被销毁
}
```

# Slice

Slice用来表示某个数据结构的连续的一部分，它不具有所有权，但是会作为原数据结构的immutable引用存在。

```rust
fn first_word(s: &String) -> &str{
    for (i, &c) in s.as_bytes().iter().enumerate(){
        if(c == b' '){
            return &s[0..i]
        }
    }
    &s[..]
}
fn main(){
    let s = String::from("hello world");
    let fw = first_word(& s);
    s.clear(); // 调用s.clear()必须先获得s的一个mut引用，而fw是s的一个imutable引用，这里会报错
    println!("{}", fw);
}
```

一些slice类型：

- 数组类型，比如`&[i32]`
- 字符串类型，`str`

# struct

rust也支持用结构体来组织数据。

```rust
struct Rect{
    width: u32,
    height: u32
}
```

结构体的初始化非常简单：

```rust
    let rect = Rect{
        width: 100,
        height: 200
    };
```

如果我们有同名变量，可以省略初始化时候使用的字段名称

```rust
    let width = 10;
    let height = 200;
    let rect = Rect{
        width,
        height
    };
```

如果你希望从另外一个变量中拷贝大部分字段，但是覆盖其中少部分字段，rust通用提供了语法糖。注意这仅仅只是个语法糖，实际上本质上还是会把需要的属性逐一进行拷贝，这可能会导致所有权的变动。

```rust
    let rect2 = Rect{
        width: 200, //覆盖rect中的字段width
        ..rect //表示从rect复制字段，必须放在最后
    };
```

## tuple structs

有时候我们并不需要一个为每个字段提供一个名字，我们需要为tuple声明一个类型。注意不同的tuple struct类型，即使拥有相同的声明，它们的实例也是不能相互转换的。

```rust
struct Point (i32, i32);

fn main() {
    let pt = Point(0, 0); //初始化
    println!("{}", pt.0); //类似于tuple通过.下标来获取元素
}
```

## unit-like struct

一个struct允许没有任何字段，这样的struct称为unit-like struct。

```rust
    struct AlwaysEqual;
    let subject = AlwaysEqual;
```

## method

我们可以为struct实现特有的函数，这类函数称为关联函数。关联函数的名称可以于struct的某个field相同。

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 { //不可变self引用
        self.width * self.height
    }
    fn init(&mut self){  //可变self引用
        self.width = 0;
        self.height = 0;
    }
}

impl Rectangle { //对于同一个struct，可以有多个impl块
    fn give_back(self) -> Rectangle { //获得所有权
        self
    }
    fn square(size: u32) -> Rectangle { //关联函数也可以没有self参数
        Rectangle{
            width:size, 
            height:size
        }
    }
}

fn main() {
    let mut rect = Rectangle {
        width: 30,
        height: 50,
    };
    let area = rect.area();
    rect.init(); //这个调用和下一行的调用是等价的，rust会自动创建引用作为第一个参数传入
    (&mut rect).init();
    rect = rect.give_back();
    rect = Rectangle::square(32);
}
```

这里`&self`是`self: &Self`的缩写，其中`Self`是impl后面接的类型在这个impl块中的别名。

# enum

rust中我们enum类型更像是一种类型的分组，它内部可以包含多个具有别名的类型。

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message{
    fn distance(&self) -> i32{
        match self {
            Message::Move { x, y  } => x + y,
            default => 0
        }
    }
}

fn main() {
    let msg = Message::Move{x : 1, y : 1};
    println!("{}", msg.distance());
}
```

# match

match可以用来处理整数、枚举、字符串等。

```rust
let roll = 1;
let mut x = 0;

let res = match roll { //match可以带返回值
    0 => 0,
    1 => 1,
    other => -1, //用other匹配所有情况
}

match roll {
    0 => x += 1,
    1 => x -= 1,
    _ => () //_表示匹配任意值并丢弃，()表示什么都不做，{}也是相同作用
}
```

枚举类型也可以同样操作：

```rust
    let max = Some(1);
    match max {
        Some(x) => println!("max = {}", x),
        _ => ()
    }
```

很多时候我们仅处理一种枚举类型，但是这要求我们总是加入`_ => ()`行，这比较麻烦，还有一种`if let`语法。

```rust
    let max = Some(1);
    if let Some(x) = max {
        println!("max = {}", x);
    } else { //else块是可选的
    }
```

# 模块管理

在rust中，用mod声明一个模块，其类似于其他语言的命名空间。模块内部可以定义其它模块，或者自定义类型、函数等。

模块中如果我们声明某个定义的元素是pub，表示这个元素的所有父模块都能访问它。要使用其它模块中的元素，我们需要通过相对路径或者绝对路径来访问。这类似于类unix系统中的路径表示法，默认路径为相对路径，我们用crate表示根路径，super表示当前元素所在mod的父mod。

每次都需要用冗长的路径来使用相同元素是很麻烦的，我们可以用use来在当前scope引入某个特定的名称。为了避免引入拥有相同名字，但是存在于不同mod下的元素，我们需要通过alias设置别名，默认别名就是元素的名称。use也有访问控制，默认这个别名是不能被mod外访问的，我们可以加入pub修饰符使得它能够被mod外访问。

```rust
mod department {
    mod service {
        use super::House; //使用别名
        pub use super::House as H; //使用别名，并暴露mod外
        use super::*; //引入父模块的所有名称
        pub fn clean(house: &mut super::House){

        }
    }

    pub struct House {
        pub address: String,
        pub opened: bool,
        key: String, //私有field
        key_type: KeyType
    }

    pub enum KeyType{
        Physical,
        Electric
    }

    impl House{
        pub fn open(&mut self, key: &String) { //公有方法
            if self.isKeyValid(key) {
                self.opened = true;
            }
        }
        pub fn newHouse() -> House{
            House {
                address: String::from("South"),
                opened: false,
                key: String::from("123"),
                key_type: KeyType::Physical,
            }
        }
        
        fn isKeyValid(&self, key: &String) -> bool { //私有方法
            &self.key == key
        }
    }

    
    pub fn simpleTest() {
        let mut house = crate::department::House::newHouse();
        let mut house = House::newHouse();
        let mut house = super::department::House::newHouse();
        service::clean(&mut house);
        use service::clean; //引入clean
        clean(&mut house);
    }
}
```

## 实战

我们可以很简单的用cargo实现模块管理。首先我们创建一个简单的项目`your_lib`。

```bin
# cargo new --lib your_lib
```

之后创建如下文件，`src\lib.rs`

```rust
pub mod sample;
```

在创建新的文件`src\sample\mod.rs`

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

之后我们在`your_lib`的父目录下建立一个项目`practice`。

```bin
# cargo new practice
```

之后修改`main.rs`文件

```rust
use your_lib::sample::add;
fn main(){
    println!("1 + 2 = {}", add(1, 2));
} 
```

但是我们还需要加入对sample项目的依赖，由于是本地依赖，我们需要修改`Cargo.toml`依赖。

```toml
simple = {path = "./your_lib"}
```



