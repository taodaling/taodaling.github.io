---
categories: technology
layout: post
---

- Table
{:toc}

# 所有权

数据可能分配在栈上和堆上。一个分配在栈上的数据可以通过默认的浅拷贝完整克隆，也更为廉价。而需要共享的数据更适合分配在堆上，这样只需要在栈上保留一个指向堆位置的指针即可，这样可以避免大量的拷贝操作。如果想要同时拷贝堆上的数据，可以用`clone`方法。

栈上的数据在退栈的时候会被自动释放，但是堆上不同。堆上的数据由于可能被多个指针引用，不能轻易决定释放时机。

Rust中引入所有权的概念，一个数据的所有权被正好一个变量获得，当这个变量离开作用域的时候，它的数据也会被销毁。

```rust
    let s1 = String::from("hello");
    let s2 = s1; //s2接管s1的所有权，s1失去了所有权，不能再被使用
```

在栈上直接分配的数据实现了名为`Copy`的`traits`，在赋值给另外一个变量的时候并不会失去所有权，而是将数据完整拷贝给了另外一个变量。

```rust
    let x = 5;
    let y = x; //x并不会失去所有权
```

以下类型的数据实现了`Copy`的`traits`：

- 基础类型
- 仅包含实现了`Copy`的`traits`数据的元组

# 引用

```rust
fn take_ownership(x: String){ //
    println!("{}", x);
}

fn main(){
    let s = String::from("hello");
    take_ownership(s); //这里s失去所有权
}
```

由于将数据作为函数参数传递也会使得变量失去所有权，因此我们必须将所有权从函数中传回。

```rust
fn take_ownership(x: String) -> String{ //
    println!("{}", x);
    x
}

fn main(){
    let s = String::from("hello");
    let s = take_ownership(s);
}
```

这样做很麻烦，尤其在参数比较多的情况下。我们可以用引用来优化这一过程。


```rust
fn borrow(x: & String){ 
    println!("{}", x);
}

fn main(){
    let s = String::from("hello");
    borrow(& s);// 这里s不会失去所有权
}
```

引用也分为`mut`和`immutable`两种。前者会对数据加写锁，后者会对数据加读锁（这里并不真的在运行期加锁，实际上都是编译期的工作，这里只是为了方便理解）。因此一个数据最多有一个`mut`类型的应用，或者多个`immutable`类型的引用。之所有这么设计是为了防止race condition。

```rust
fn main(){
    let mut s = String::from("hello"); //s得到所有权
    let mut_ref_s = &mut s; //获得一个mut引用
    mut_ref_s.push_str(" world"); //修改mut引用，由于这里是mut_ref_s的最后一次被使用，因此它的生命周期在此结束
    let immutable_ref_s = &s; //创建一个immutable引用
    println!("{}", immutable_ref_s);
}
```

如果所有权变量被销毁，那么所有存活的引用（这种引用称为悬置引用，dangling reference）都是不可用的，这时候再使用这些引用对象会引起编译错误。

```rust
fn wrong() -> &String {
    let s = String::from("hello");
    &s //在这语句后s会销毁，因此返回的引用也将非法
}

fn correct() -> String {
    let s = String::from("hello");
    s //返回所有权可以避免数据被销毁
}
```

# Slice

Slice用来表示某个数据结构的连续的一部分，它不具有所有权，但是会作为原数据结构的immutable引用存在。

```rust
fn first_word(s: &String) -> &str{
    for (i, &c) in s.as_bytes().iter().enumerate(){
        if(c == b' '){
            return &s[0..i]
        }
    }
    &s[..]
}
fn main(){
    let s = String::from("hello world");
    let fw = first_word(& s);
    s.clear(); // 调用s.clear()必须先获得s的一个mut引用，而fw是s的一个imutable引用，这里会报错
    println!("{}", fw);
}
```

一些slice类型：

- 数组类型，比如`&[i32]`
- 字符串类型，`str`

# struct

rust也支持用结构体来组织数据。

```rust
struct Rect{
    width: u32,
    height: u32
}
```

结构体的初始化非常简单：

```rust
    let rect = Rect{
        width: 100,
        height: 200
    };
```

如果我们有同名变量，可以省略初始化时候使用的字段名称

```rust
    let width = 10;
    let height = 200;
    let rect = Rect{
        width,
        height
    };
```

如果你希望从另外一个变量中拷贝大部分字段，但是覆盖其中少部分字段，rust通用提供了语法糖。注意这仅仅只是个语法糖，实际上本质上还是会把需要的属性逐一进行拷贝，这可能会导致所有权的变动。

```rust
    let rect2 = Rect{
        width: 200, //覆盖rect中的字段width
        ..rect //表示从rect复制字段，必须放在最后
    };
```

