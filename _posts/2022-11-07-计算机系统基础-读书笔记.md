---
categories: note
layout: post
---

- Table
{:toc}

# 计算机系统概述

**计算机分代**
- 第一代：电子管计算机
- 第二代：晶体管计算机
- 第三代：集成电路计算机
- 第四代：超大规模集成电路计算机

**摩尔定律**：由于硅技术的不断改进，每18个月，集成度将翻一番，速度将提高一倍，而其价格将降低一半。

**计算机系统基本功能**
- 数据处理，运算部件负责
- 数据存储，存储部件负责
- 数据传输，互连部件负责

**计算机系统组成部分**

- 硬件：物理装置的总称
  - CPU
  - 存储器
  - 外设：输入输出设备
  - 总线：在部件之间传输信息，分别由处理器总线、存储器总线、I/O总线连接CPU，存储器和外设。总线之间通过I/O桥接器相连。
- 软件：程序和数据
  
**指令执行**

- 指令执行时，通过CPU中的控制器对指令操作码进行译码，解释成控制信号控制数据通路执行。
- 指令执行由时钟信号进行定时，一条指令的执行需要若干个时钟的时间。

**ISA**

软件和硬件之间交互的桥梁是通过指令集体系结构（Instruction Set Architecture，ISA）所定义的。ISA规定了每条指令计算机执行什么具体的操作。

ISA是一种规范，而实现的组织称为微架构。微架构通过逻辑电路实现。

机器语言程序时ISA规定的指令的序列。

## 性能测试

用户感觉到的程序执行时间分为CPU时间和其他时间，CPU时间分为用户CPU时间和系统CPU时间。
- 时钟周期：每一条指令都被分为若干步骤，每一步动作都需要相应的控制信号进行控制。这些控制信号发出的时机，需要由相应的定时信号进行同步。CPU能够产生同步的时钟定时信号，也就是CPU的主脉冲信号，其宽度称为时钟周期。
- 时钟频率：CPU的主频就是CPU的主脉冲信号的时钟频率，是CPU时钟周期的倒数
- CPI（Cycles Per Instruction)：表示执行特定指令需要的时钟周期数。对于程序或机器来说，CPI指该程序或机器指令集中的所有指令执行所需的平均时钟周期数。

用户CPU时间=程序总时钟周期数\*时钟周期

最早用来衡量计算机性能的指标是每秒钟完成的单个运算指令的条数，当时大多数指令的执行时间是相同的，因此通常使用加法指令，指令速度的计量单位为MIPS（Million Instruction Per Second）。

还有一种方式，叫做指令平均执行时间，或等效指令速度法、Gibson混合法。设某类指令$i$在程序中占到的比例为$w_i$，单个指令执行时间为$t_i$，则等效指令的执行时间为：$T=\sum_{i=1}^nw_it_i$。如果执行时间用时钟周期数来衡量，则上式计算的结果就是CPI，对指令平均执行时间求导数可以得到MIPS值。

选取一组指令组合，使得得到的平均CPI最小，由此得到的MIPS称为峰值MIPS。有些制造商经常将峰值MIPS直接当作MIPS，而实际性能会比标称的性能差。

MIPS不能准确衡量机器的性能，因为不同机器的指令集不同，可能在某台机器上一条指令的内容需要在另外一台机器上多条指令来完成。

MIPS描述的是定点指令运算，而对于浮点操作速度的指标为MFLOPS（Million FLOating-point operations Per Second）。它表示每秒所执行的浮点运算有多少百万次，它基于完成的操作次数而不是指令数。

基准程序是进行计算机性能评测的一种重要工具，它们是一组专门用来进行性能评价的程序，能很好地反映机器在实际运行时的性能。基准程序最好是用户经常使用的一些实际程序。要比较不同机器上的测试结果，对于不同程序的耗时我们可以进行加权计算出平均耗时，从而比较不同的机器性能。

# 数据的机器级表示与处理

计算机内部采用的是二进制表示方式，原因如下：
- 二进制只有两种基本状态，制造有两个稳定状态的物理器件比有多个稳定状态的器具容易很多
- 二进制的编码、计数和运算规则很简单
- 0，1可以对应逻辑真假值，可以容易实现逻辑判断

**数据类型**
- 数值数据：表示数值，可以比较大小，分为定点数和浮点数
- 非数值数据：没有大小之分，仅用于存储数据，表示方式为位串

## 进制

一般我们在数值后面加上符号来表示它的进制
- B：二进制（Binary）
- O：八进制（Octal）
- D：十进制（Decimal）
- H：十六进制（Hexadecimal）

R进制转十进制，只需要每一位的值乘上它的权值，并加总即可。

十进制数转R进制数，需要拆分成整数和小数部分分别进行转换。
- 整数部分通过取余来实现
- 小数部分通过不断乘R，而得到的新值的整数位就是当前位值

比如135.6875，将它转换位二进制表示，先处理整数

```
135 => 1
67 => 1
33 => 1
16 => 0
8 => 0
4 => 0
2 => 0
1 => 1

135D = 10000111B
```

再处理小数

```
0.6875 => 0
1.375 => 1
0.75 => 0
1.5 => 1
1 => 1

0.6875D = 0.1011B
```

## 定点数的编码表示

整数由于小数点固定在数的最右边，而实数的小数点并不固定。计算机中通过约定小数点位置来实现数值表示，小数点固定在特定位置的数称为定点数，而小数点可以浮动的数称为浮点数。

定点数可以用来表示定点小数和定点整数。前者约定小数点在数的最左，而后者则约定小数点在数的最右。

定点数的编码可以分为如下几类

- 原码表示法：由首位表示符号，其余位表示数值。问题会出现两种0的编码表示，并且会使得加减运算必须引入逻辑判断从而复杂化。计算机中不使用原码来表示整数，但是使用定点原码小数来表示浮点数的尾数部分。
- 补码表示法：对于具有一个符号位和$n-1$个数值位的二进制整数$X$的补码，定义为$\[X\]=2^n+X (\mod 2^n)$
- 反码表示法：如果在补码表示法中，我们用$2^n+X-1(\mod 2^n)$来表示负数，那么这时候我们使用的就是反码表示法。但是反码中全0即可表示0，也可以表示$-(2^{n-1}-1)$，因此一般不被使用。
- 移码表示法：浮点数的指数一般用一种称为移码的编码方式表示。当进行浮点数的加减运算时，必须先对阶，为了简化比较操作，不必考虑阶的符号，可以对每个阶都加上一个正常数，称为偏置常数。

## 浮点数的编码表示

对于浮点数，考虑任意实数$X$，它都可以表示成下面形式：$X=(-1)^S\times M\times R^E$。其中$S$取值为0或1，$M$则是一个定点小数，称为$X$的尾数，$E$是一个定点整数，称为$X$的指数（阶），$R$是基数。尾数的位数决定数的精度，指数的位数决定数的范围，并且也指定小数点的位置。

对于二进制数，考虑尾数位数为$n$，指数位数为$m$，那么绝对值最小的非零数为$0.0\ldots 01\times R^{-11\ldots 1}$，最大的数为$0.11\ldots 1\times R^{11\ldots 1}$。

$$
2^{-n}\times 2^{-(2^m-1)}\leq |x|\leq (1-2^{-n})\times 2^{2^m-1}
$$

超出可以表示最大绝对值区间称为上溢区，接近0但是绝对值小于最小绝对能够值区间称为下溢区。

只要尾数为0，不管阶码怎么取都表示0，这样的数称为机器零，因此机器零的表示不唯一。通常在尾数为0时，都强制将阶码取0。

机器零有+0和-0的区分。

在运算过程中会尽可能保留有效数字的位数，这时候采用规格化操作，来保留尽量多的有效数位，并且使浮点数的表示具有唯一性。规格化操作分为左规和右规，当有效数位进到小数点之前，需要尾数右移，同时增加阶码。同理如果尾数首位为0，且值不是0，则需要进行左规，尾数左移，同时阶码减少。

**IEEE 754**

为了统一浮点数的表示格式，IEEE成立委员会着手制定浮点数标准，1985年完成了浮点数标准IEEE 754的制定，成为了目前的实际标准。其中提供了32与64位浮点数格式。

|浮点数位数|符号|阶码|尾数|
|-|-|-|-|
|32|1|8|23|
|64|1|11|52|

其中阶码通过移码编码，尾数用原码表示。

由于规格化保证尾数的第一位总为1，因此可以缺省第一位的1，该缺省位称为隐藏位，使得实际表示的尾数位数比规定多一位。

在IEEE 754中有如下额外规定：
- 隐藏位1的位置在小数点前。
- 阶码的移码偏置常数为$2^{n-1}-1$。

IEEE 754同时对规定了下面特殊位序列的解释

|值的类型|符号|阶码|尾数|
|-|-|-|-|
|正零|0|0|0|
|负零|1|0|0|
|正无穷大|0|全1|0|
|负无穷大|1|全1|0|
|非数|任意|全1|非0|
|规格化非零正数|0|非全0且非全1|任意|
|规格化非零负数|1|非全0且非全1|任意|
|非规格化正数|0|0|非全0|
|非规格化负数|1|0|非全0|

**非规格化数**

非规格化数的引入，可以用于处理阶码下溢，允许存储比最小阶码还要小的数，这时候隐藏位为0。非规格数的阶为最小阶（即偏置后的1）。

**非数**

非数的引入的目的是为了检测非初始化值得使用，同时允许程序在计算出现异常得情况下继续进行下去。如果尾数的最高位为1时，为不发信号的NaN，否则为发信号的NaN。

在执行没有数学解释的计算的情况下会产生一个非数（比如0/0）。

## 十进制数的表示

计算机可以通过BCD码来通过二进制表示十进制数。计算机中有专门的逻辑线路使得每4位二进制数按十进制进行处理。

由于用4位16个数来表示10个数，因此选择方案非常多。
- 有权BCD码：使用的四个二进制位有各自的权。最常用的是8421码，选择二进制计数顺序的前10个代码与十进制数字相对应。
- 无权BCD码：使用的四个二进制位没有确定的权。

## 非数值数据的编码

**逻辑值**

逻辑数据通过一串0/1序列表示，需要通过指令的操作码类型来识别它们。

**西文字符**

ASCII码为美国标准信息交换码，每个字符占一个字节$b_7b_6b_5b_4b_3b_2b_1b_0$，最高位$b_7$为0，其中$b_6b_5b_4$称为高位，$b_3b_2b_1b_0$称为低位。
- 字符0~9的高三位为011，低四为为0000~1001。
- 英文字母，$b_5$为0表示小写字母，否则为对应的大写字母。

## 数据的宽度和单位

二进制数据的每一位称为比特（bit），比特是计算机中操作的最小存储单位。

一个字节（byte）等于8个比特。

字（word）由若干字节组成。

字长，通常指CPU内部用于整数运算的数据通路的宽度。需要注意字长不一定等于字的长度。

## 数据的排列

一般用LSB（Least significant bit）表示最低有效位，而用MSB（Most significant bit）表示最高有效位。

对于多字节数据，计算机中数据被存放在连续的空间中，根据数据字节的排列顺序不同，可以分为大端和小端。大端将MSB放在低字节处，而小端将LSB放在低字节中。

## 二进制运算

**左移运算和右移运算**

二进制位移可以分为逻辑移位和算术移位，区别在于前者在右移的时候最高有效位补0，而后者补充最高位相同值。

默认情况下，对无符号整数采用逻辑移位，而对有符号整数采用算术移位。

算术移位的意义在于对于负数，右移移动一位等价于上整除2。

**位扩展运算和位截断运算**

在短类型转换为长类型的时候，需要进行位扩展。扩展后的数值应该保持不变。

对于无符号整数，在高位补充0，对于有符号整数，在高位补充符号位。

截断运算表示从长类型转换为短类型时，仅保留较低的若干位。

## 算术运算

**整数加减运算**

减法是通过将计算被减数和减数的补码的和来实现的。所以只需要实现加法即可。

输出标志会保存到标志寄存器中
- ZF：1表示结果为0
- OF：1表示带符号整数的加减运算发生溢出
- SF：带符号整数加减运算结果的符号位
- CF：表示无符号数加减运算时的进/借位

**整数乘除运算**

带符号整数的乘法和无符号相同。

带符号除法，不存在溢出问题，需要向靠近零的方向舍入。

在计算机中，一次乘法需要大概10个时钟周期，而一次除法运算需要大概30个时钟周期。所以编译器在处理一些乘除运算时会把它自动优化成移位运算。

**浮点数加减运算**

计算机完成浮点数运算需要经过下面步骤
- 对阶：使两个数的阶相同，小阶向大阶看齐，同时尾数右移（隐藏位也需要右移）
- 尾数加减：此时两个数的阶相同，之后可以直接对尾数进行加减。
- 尾数规格化
- 尾数的舍入处理

上面的过程中需要为尾数保留额外的附加位（在最右侧）来获得更高的精度的运算结果。IEEE 754标准规定，所有浮点数运算的中间结果右边至少需要保留两个附加位，次低位称为保护位，最低位称为舍入位。为了进一步提高计算精度，在舍入位后还增加一个额外的数位，称为粘位，只要舍入位右边有任何非0数字，粘位则始终为1，否则为0。

而对于具体的舍入策略，有如下几种选择：
- 就近舍入到偶数：即默认舍入到最近值，如果存在两个最近值，则舍入到偶数那个。
- 朝上舍入
- 朝下舍入
- 朝0舍入

**浮点数乘除运算**

在进行乘除运算之前，需要对操作数进行判0处理、规格化操作和溢出判断，并确定参加运算的两个操作数是正常的规格化浮点数。

乘除运算不需要对阶，可以直接对阶进行加减运算。

# 程序的转换及机器级表示

机器语言程序是由若干条机器指令组成的序列，每条机器指令由若干字段组成，而每个字段都是一串由0和1组成的二进制数字序列。

为了能直观表示机器语言程序，引入了一种与机器语言一一对应的符号化表示语言，称为汇编语言。

将汇编语言编写的程序翻译成机器语言的程序称为汇编程序，反向翻译的程序称为反汇编程序。

ISA抽象了硬件层级提供的支持，规定了支持的命令、寄存器的长度等。

## 缓冲区溢出攻击

由于返回地址存储在栈上，因此黑客可以利用栈中分配的缓冲区的写溢出，用恶意代码段的首地址替代返回地址，那么就可以引导用户程序去执行他们的恶意代码。

缓冲区溢出非常容易达成，同时也有下面的防范手段
- 地址空间随机化：将加载程序时生成的代码段、静态数据段、堆区、动态库和栈区各部分的首地址进行随机化处理
- 栈破坏检测：在函数的准备阶段，在栈帧中的缓冲区底部与保存寄存器状态之间加入一个随机生成值，在恢复寄存器并返回到调用函数前，先检查该值是否被篡改。
- 可执行代码区域限制：通过将程序的数据段地址空间设置为不可执行，从而使得攻击者不能执行被植入在输入缓冲区中的代码。


