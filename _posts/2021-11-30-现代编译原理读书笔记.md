---
categories: technology
layout: post
---

- Table
{:toc}

# 分词

分词是指将程序分解为token流，这样可以简化后面对程序的处理。

分词器可以通过正则表达式实现，复杂一些的可以通过状态机手工实现。

## 正则表达式

正则表达式的具体定义和构造方法可以参考我的另外一篇文章《正则表达式》。这里简单引入一些符号：

- symbol: 对应字符集中的一个特定字符，比如$a$
- alternation: 表示或关系$a|b$表示匹配$a$或匹配$b$。
- concatenation: 表示且关系，$a\cdot b$表示先后匹配$a$和$b$，也可以缩写为$ab$。
- epsilon: 表示一个空字符串，记作$\epsilon$。
- repetition: 表示匹配任意次，比如$(a|b)*$。

我们称字母表为所有词法分析器可能产生的token的集合。

# 语法分析

语法分析是指理解token流，并依照它构建一个语法树（Abstract Syntax Tree）。

正则表达式是纯粹通过状态机实现的，但是状态机存在一个致命问题，就是只有$n$个状态的状态机无法识别$n$层以上的嵌套，因此我们无法用一个只包含$n$个状态的正则表达式来判断一个括号序列是否合法。而递归的能力恰好又是语法分析所需要的。

我们需要一种能描述合法的程序的方法，称之为语法。

## 上下文无关语法

产生式(production)为如下形式的表达式：

```
symbol -> symbol symbol ... symbol
```

产生式的右边有任意数目的符号（symbol），符号分为两类：

- 终止符（terminal）：字母表中的单词，只能出现在表达式的右部。
- 非终止符（nonterminal）：由产生式所描述的符号。

我们采用的语法类似于正则表达式，但是我们允许展开正则表达式的或关系，`A=a|b|c`等价于

```
A->a
A->b
A->c
```

也可以写作：

```
A->a
A->b
A->A|c
```

它们都是等价的。

比如我们定义语法：

```
Digit->num
Expr->Digit
Expr->Expr + Expr
Expr->(Expr)
```

存在多种推导方法可以得到相同的程序，每次取最左非终止符替换的方式称为最左推导，而每次取最右非终止符替换的方式称为最右推导，现在我们利用最左从`Expr`推导得到文本`2+(4+3)+1`

```
Expr
Expr+Expr
Expr+Expr+Expr
Digit+Expr+Expr
2+Expr+Expr
2+(Expr+Expr)+Expr
2+(Digit+Expr)+Expr
2+(4+Expr)+Expr
2+(4+Digit)+Expr
2+(4+3)+Expr
2+(4+3)+Digit
2+(4+3)+1
```

将每个符号作为一个顶点，可以发现程序是由一个根顶点推导得到的，这能得到一颗语法树。

## 语法二义性

如果一个语法能推导出相同的程序，但是构造的语法树不同，那么这个语法是有二义性的。比如`2-1-1`，它可能推导出

```
-
|   \
2   -
    |   \
    1   1
```

也可能推导出

```
-
|       \
-       1
|   \
2   1
```

两者对应的结果分别为`2-(1-1)`和`(2-1)-1`，因此相同的程序，不同的语法树会导致不同的执行结果。

二义性语法会带来问题，幸运的是我们往往可以将二义性语法转换为无二义性的语法。

比如上面的语法，我们希望减号左结合，我们可以通过引入一个额外的符号来实现。

```
E -> E-T
T -> num
```

我们一般可以通过改造语法来消除二义性，但是有些语言不存在无二义性的语法，这种语言不适合用作程序设计语言。

在语法中我们一般用S表示开始符号，\$表示结束符号（文件尾）。S\$则一般表示语法树的根。

## LL解析

通过递归的方式，如果每个非终止符都可以通过token流开始的1个token确定选择哪个右部进行分解，那么我们可以实现一个递推下降的语法分析器。这种分析方法叫做预测分析。

对于产生式：$X\rightarrow \gamma$

- 记$\mathrm{FIRST}(\gamma)$表示所有$\gamma$能推导得到的token序列中最开始终止符所形成的的集合
- 记$\mathrm{nullable}(X)$表示$X$是否可以推导为空字符串。
- 记$\mathrm{FOLLOW}(X)$表示所有能跟在$X$后面的终止符的集合。

同理我们可以定义一个符号序列是可空的，当且仅当每个符号都是可空的。

我们给出计算$\mathrm{FIRST}$和$\mathrm{FOLLOW}$的算法。

```
Initialize FIRST and FOLLOW to all empty sets, and nullable to all false
for each terminal symbol Z
    FIRST[z] <- {Z}
repeat
    for each production X -> Y1 Y2 ... Yk
        for each i from 1 to k, each j from i + 1 to k,
            if all the Yi are nullable
                then nullable[X] <- true
            if Y1 ... Yi-1 are all nullable
                then FIRST[X] <- FIRST[X] + FIRST[Yi]
            if Yi+1 ... Yk are all nullable
                then FOLLOW[Yi] <- FOLLOW[Yi] + FOLLOW[X]
            if Yi+1 ... Yj-1 are all nullable
                then FOLLOW[Yi] <- FOLLOW[Yi] + FIRST[Yj]
until FIRST, FOLLOW and nullable did not change in this iteration 
```

考虑语法：

```
Z->d
Z->XYZ
Y->
Y->c
X->Y
X->a
```

它的FIRST、nullable、FOLLOW函数如下：

||nullable|FIRST|FOLLOW|
|-|-|-|-|
|X|yes|a c|a c d|
|Y|yes|c|a c d|
|Z|no| a c d | 

之后我们需要构建一个二维表，每个单元都由$(X,T)$所描述，其中$X$和$T$分别是非终止符和终止符。这张表叫做predictive parsing table，预测解析表。考虑产生式$X\rightarrow \gamma$，如果$T\in \mathrm{FIRST}(\gamma)$，或者$\gamma$是可空的且$T\in \mathrm{FOLLOW}(X)$，那么我们就在$(X,T)$填入这条产生式。

||a|c|d|
|-|-|-|-|
|X|$X\rightarrow a\\X\rightarrow Y$| $X\rightarrow Y$ | $X\rightarrow Y$ |
|Y|$Y\rightarrow$|$Y\rightarrow\\Y\rightarrow c$|$Y\rightarrow$ |
|Z|$Z\rightarrow XYZ$|$Z\rightarrow XYZ$ |$Z\rightarrow XYZ\\Z\rightarrow d$|

很显然我们可以通过多种方式从$Z$推导得到$d$，因此这种语言是二义性的。如果预测解析表中每个单元格中最多只有一个产生式，则这种语法称为LL(1)语法，意思为`Left-to-right parse, Leftmost-derivation,1-symbol lookahead`。

对应的如果我们用$\mathrm{FIRST}(\gamma)$表示所有能推导字符串最开始的$k$个终止符，并且得到的解析表不存在二义性，则这种语法称为LL(k)语法。一个LL(k)语法必定是LL(k+1)语法。但是对于较大的k这种语法一般是不实用的，因为它会耗尽内存。

### 消除左递归

考虑下面产生式：

```
E->E+T
E->T
```

这个产生式一定会产生重复单元格，因为$\mathrm{FIRST}(E)\subseteq \mathrm{FIRST}(E+T)$，即如果$T\in \mathrm{FIRST}(E)$，则$T\in \mathrm{FIRST}(E+T)$，$(E,T)$单元格至少有两个产生式。这里的问题是$E$发生了左递归，所有带左递归的语法都不可能是LL(1)。

我们可以通过引入一个新的非终止符来消除左递归，下面的语法是LL(1)的。

```
E->TE'
E'->+TE'
E'->
```

还有一种比较经典的方式消除重复单元格，就是如果某个非终止符的两个产生式有一段公共前缀：

```
S->if E then S else S
S->if E then S
```

那么我们可以提取公共前缀并引入一个新的终止符。

```
S->if E then SX
X->else S
X->
```

## LR解析

LL(k)解析技术的问题在于我们必须在只知道k个token的前提下决定使用哪个产生式。LR(k)是一种更加强大的解析技术，它允许我们在看到匹配某个产生式的输入token（以及额外的k个输入token）后才需要决定使用哪个产生式。

LR(k)是Left-to-right parse，Rightmost-derivation，k-token lookaheadd的缩写。LL是自顶向下的算法，而LR是自低向上的算法。

LR(k)解析器会维护一个栈和输入流。我们允许查看输入流的前k个token。基于栈和输入流中的内容，解析器可能执行两种操作：

- Shift：将输入流的第一个token压入栈中
- Reduce：选择一个产生式`X->ABC`，从栈中分别弹出C、B、A，之后将X压入栈。

一旦我们Shift文件尾符号\$，那么解析器就会停止，这个Shift操作称作accepting。

那么LR(k)是如何判断该使用哪个操作呢？它实际通过一个DFA来实现。我们会利用DFA来分析栈上的数据。实际上我们可以用Aho–Corasick算法来做，并且记录每个栈上元素对应的自动机状态，这样所有的Shift和Reduce都可以用摊还$O(1)$的时间复杂度实现。

SLR是一种比LR(0)更好的解析方法，它与LR(0)的区别在于在Reduce之前必须保证超前查看的元素$e$在归约结果$X$的$\mathrm{FOLLOW}$集合中。但是它的缺点在于即使$e$在$X$的$\mathrm{FOLLOW}$集合中，也不能保证是否需要规约，比如：

```
X->T
X->Ta
```

且$a\in \mathrm{FOLLOW}(X)$，那么我们在遇到$T.a$的时候是否要规约是不确定的。

### LR(1)

实践上我们很少会使用$k>1$的情况，因为这会导致状态机很大。而且实际上所有由LR(k)所描述的代码也都可以通过LR(1)语法描述，这不过更加复杂而已。LR(0)是哪些仅通过观察栈上数据就可以判断执行什么操作的语言，这类语法表达能力比较差，并不实用。

下面重点讲一下最有实用价值的LR(1)的构建算法。这里我们使用的下面的语法案例讲解：

```
Goal->List
List->List Pair
List->Pair
Pair->( Pair )
Pair->()
```

如果我们在处理了前$k$个字符后，用$A\rightarrow \beta$来做归约，称$(A\rightarrow \beta, k)$是一个句柄。而LR(1)语法分析的关键就是要找到句柄。LR(1)语法分析器使用一种句柄查找自动机，该自动机通过两个表实现，分别为Action和Goto，Action表告诉我们下一步操作，而Goto则告诉我们状态的转移。我们具体的自动机代码如下。

```
push $
push start state, s0;
word <- NextWord();
while(true) do;
    state <- top of stack
    if Action[state.word] = "reduce A->B" then begin;
        pop 2|B| symbols;
        state <- top of stack;
        push A;
        push Goto[state, A]
    end;
    else if Action[state, word] = "shift si" then begin;
        push word;
        push si;
        word <- NextWord();
    end;
    else if Action[state] = "accept" 
        then break;
    else fail();
end;
report success;
```

现在我们剩下的任务就是构建Action和Goto表了。

Action和Goto表编码了在语法分析过程中需要用到的所有潜在句柄的信息，因此我们的表构建算法对句柄、潜在句柄和前瞻符号都需要一种具体的表示。每个潜在的句柄都表示为一个LR(1)项，一个LR(1)项$[A\rightarrow \beta\cdot \gamma, a]$包含一个产生式$A\rightarrow\beta \gamma$以及一个占位符$\cdot$表示栈顶在产生式右侧句型中的位置，和一个特定的终止符$a$作为前瞻符号。

我们还需要先建立句柄识别自动机的一个模型，并使用这个模型来填充表，这个模型称为LR(1)项集的规范族（canonical collections of sets of LR(1) items），它们表示自动机所有的状态和状态之间的转移。

我们制定规范族$CC=\left\\{CC_0,\ldots,CC_n\right\\}$。算法通过跟踪语法中的产生式来构建CC，在最终的集族CC中，每个集合$CC_i$都是语法分析器某个可能状态中所有潜在句柄的集合。

对于LR(1)项，我们需要额外的解释：

1. $[A\rightarrow \cdot \beta\gamma,a]$表示A可能是有效的。
2. $[A\rightarrow \beta\cdot \gamma,a]$表示我们已经匹配了部分产生式的右部。
3. $[A\rightarrow \beta \gamma\cdot,a]$表示我们已经匹配了整个产生式，并且在这个上下文中，如果前瞻符号是$a$，则该项是一个句柄（即需要归约）。

可以发现的项的数目上限为$O(Nm)$，其中$N$表示所有产生式右侧的总长，而$m$表示终止符的类型数量。

下面我们讨论如何建立规范族，这里我们需要两个项集上的基本操作：

- 取闭包（closure）：对于某个核心项集，该运算将其中项中·后的非终止符进一步展开，并将所有得到的新的项加入到自身中。重复上面操作直到集合不再变化。比如[Goal->·List,eof]，它可以继续展开为：[Goal->·List Pair,eof]和[Goal->·Pair,eof]。最后得到的集合称作完备的。
- 转移（goto）：当状态遇到新的输入符号x，算法找到其中满足·在x之前的所有状态，将·后移一位得到所有项组成新的状态。

为了简化问题，我们要求语法需要有一个唯一的目标符号，且这个符号不会出现在任何一个产生式的右侧。只有在我们产生了目标符号后，并且前瞻符号为eof，这时候我们会接受输入。在我们的案例中可以选择Goal作为目标符号。

项[Goal->·List,eof]是我们的初始状态，每个有效的语法分析过程都必须最终识别出Goal后跟eof。初始时$CC_0$中仅包含这一个项。

closure的具体算法如下：

```
closure(s)
    while(s is still changing)
        for each item [A->B·CD,a] in s
            for each production C->y in P
                for each b in FIRST(Da)
                    s <- s + {[C->·y,b]}
```

同理发现我们需要考虑的FIRST集合只有$O(Nm)$个，因此程序会很快终止的。

在我们对$CC_0$执行closure操作后，就得到了完备的$CC_0$。

goto的具体算法如下：

```
goto(s, x)
    moved <- empty set
    for each item i in s
        if the form of i is [A->B·xC, a] then
            moved <- moved + {[A->Bx·C,a]}
    return closure(moved)
```

下面给出计算规范族的算法：

```
CC0 <- closure({[S'->·S,eof]})
CC <- {CC0}
while (new sets are still being added to CC)
    for each unmarked set CCi in CC
        mark CCi as processed
        for each x following a · in an item in CCi
            temp <- goto(CCi, x)
            if temp not in CC
                then CC <- CC + {temp}
            record transition from CCi to temp on x
```

由于我们的项的数目上限为$O(Nm)$，因此CC的大小上限为$O(2^{Nm})$。

下面我们创建Action和Goto表：

```
for each CCi in CC
    for each item I in CCi
        if I is [A->B·cD,a] and goto (CCi, c) = CCj then
            Action[i, c] <- "shift j"
        else if I is [A->B·,a] then
            Action[i, a] <- "reduce A->B"
        else if I is [S'->S·,eof] then
            Action[i, eof] <- "accept"
    for each non terminal n
        if goto(CCi, n) = CCj then
            Goto[i, n] <- j
```

## 错误恢复

有时候我们希望编译器能找到尽可能多的错误，这就要求我们编译器在遇到错误后能恢复到正确状态。

大部分语言都用分号来表示语句结尾，因此我们编译器可以丢弃下个分号及之前的所有输入，并重置为正确状态，从下个语句开始解析。

当我们使用LR(1)的时候，问题会更加复杂，因为我们维护了整个栈。一般做法是我们同时要退栈，直到遇到一个状态s，满足`Goto[s,Statement]`不会报错。

# 参考资料

- 《现代编译原理》
- 《编译器设计》