---
categories: technology
layout: post
---

- Table
{:toc}

# 分词

分词是指将程序分解为token流，这样可以简化后面对程序的处理。

分词器可以通过正则表达式实现，复杂一些的可以通过状态机手工实现。

## 正则表达式

正则表达式的具体定义和构造方法可以参考我的另外一篇文章《正则表达式》。这里简单引入一些符号：

- symbol: 对应字符集中的一个特定字符，比如$a$
- alternation: 表示或关系$a|b$表示匹配$a$或匹配$b$。
- concatenation: 表示且关系，$a\cdot b$表示先后匹配$a$和$b$，也可以缩写为$ab$。
- epsilon: 表示一个空字符串，记作$\epsilon$。
- repetition: 表示匹配任意次，比如$(a|b)*$。

我们称字母表为所有词法分析器可能产生的token的集合。

# 语法分析

语法分析是指理解token流，并依照它构建一个语法树（Abstract Syntax Tree）。

正则表达式是纯粹通过状态机实现的，但是状态机存在一个致命问题，就是只有$n$个状态的状态机无法识别$n$层以上的嵌套，因此我们无法用一个只包含$n$个状态的正则表达式来判断一个括号序列是否合法。而递归的能力恰好又是语法分析所需要的。

我们需要一种能描述合法的程序的方法，称之为文法。

## 上下文无关文法

产生(production)式为如下形式的表达式：

```
symbol -> symbol symbol ... symbol
```

产生式的右边有任意数目的符号（symbol），符号分为两类：

- 终止符（terminal）：字母表中的单词，只能出现在表达式的右部。
- 非终止符（nonterminal）：由产生式所描述的符号。

我们采用的文法类似于正则表达式，但是我们允许展开正则表达式的或关系，`A=a|b|c`等价于

```
A->a
A->b
A->c
```

也可以写作：

```
A->a
A->b
A->A|c
```

它们都是等价的。

比如我们定义文法：

```
Digit->num
Expr->Digit
Expr->Expr + Expr
Expr->(Expr)
```

存在多种推导方法可以得到相同的程序，每次取最左非终止符替换的方式称为最左推导，而每次取最右非终止符替换的方式称为最右推导，现在我们利用最左从`Expr`推导得到文本`2+(4+3)+1`

```
Expr
Expr+Expr
Expr+Expr+Expr
Digit+Expr+Expr
2+Expr+Expr
2+(Expr+Expr)+Expr
2+(Digit+Expr)+Expr
2+(4+Expr)+Expr
2+(4+Digit)+Expr
2+(4+3)+Expr
2+(4+3)+Digit
2+(4+3)+1
```

将每个符号作为一个顶点，可以发现程序是由一个根顶点推导得到的，这能得到一颗语法树。

## 文法二义性

如果一个文法能推导出相同的程序，但是构造的语法树不同，那么这个文法是有二义性的。比如`2-1-1`，它可能推导出

```
-
|   \
2   -
    |   \
    1   1
```

也可能推导出

```
-
|       \
-       1
|   \
2   1
```

两者对应的结果分别为`2-(1-1)`和`(2-1)-1`，因此相同的程序，不同的语法树会导致不同的执行结果。

二义性文法会带来问题，幸运的是我们往往可以将二义性文法转换为无二义性的文法。

比如上面的文法，我们希望减号左结合，我们可以通过引入一个额外的符号来实现。

```
E -> E-T
T -> num
```

我们一般可以通过改造文法来消除二义性，但是有些语言不存在无二义性的文法，这种语言不适合用作程序设计语言。

在文法中我们一般用S表示开始符号，\$表示结束符号（文件尾）。S\$则一般表示语法树的根。

## 预测分析

通过递归的方式，如果每个非终止符都可以通过token流开始的k个token确定选择哪个右部进行分解，那么我们可以实现一个递推下降的语法分析器。这种分析方法叫做预测分析。

对于由终止符和非终止符组成的序列$\gamma$

- 记$\mathrm{FIRST}(\gamma)$表示所有$\gamma$能推导的最开始终止符形成的的集合
- 记$\mathrm{nullable}(X)$表示$X$是否可以推导为空字符串。
- 记$\mathrm{FOLLOW}(X)$表示所有能跟在$X$后面的终止符的集合。





# 参考资料

- 《现代编译原理》